<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://xiaohanyu.me/</id>
  <title>行者无疆 始于足下</title>
  <updated>2015-04-10T20:00:00Z</updated>
  <link rel="alternate" href="http://xiaohanyu.me/"/>
  <link rel="self" href="http://xiaohanyu.me/atom.xml"/>
  <author>
    <name>Xiao Hanyu</name>
    <uri>http://xiaohanyu.me</uri>
  </author>
  <entry>
    <id>tag:xiaohanyu.me,2015-04-11:/2015/04/10/2014-summary/</id>
    <title type="html">2014，漫步</title>
    <published>2015-04-10T20:00:00Z</published>
    <updated>2015-04-10T20:00:00Z</updated>
    <link rel="alternate" href="http://xiaohanyu.me/2015/04/10/2014-summary/"/>
    <content type="html">&lt;p&gt;“亡羊补牢，未为迟也”， 15 年已然过了三分之一，而我才开始憋 14 年的年终总结，想来必是颓废日久，点墨已尽的缘故。 Anyway, better late than never&amp;nbsp;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://cnlox.is-programmer.com/posts/31605.html"&gt;再见，2011&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://cnlox.is-programmer.com/posts/37030.html"&gt;2012，静水深流&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://cnlox.is-programmer.com/posts/43206.html"&gt;2013，青春绝版&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自 11 年毕业后开始养成写年终总结的习惯。时过四载，本人依旧无功无业，闲散江湖。所赖家妻不弃，下嫁与我，如此， 14&amp;nbsp;年才总算没有白过。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;很多事来不及思考&lt;/p&gt;
&lt;p&gt;就这样自然发生了&lt;/p&gt;
&lt;p&gt;在丰富多彩的路上&lt;/p&gt;
&lt;p&gt;注定经历风雨&lt;/p&gt;
&lt;p&gt;让它自然地来吧&lt;/p&gt;
&lt;p&gt;让它悄然地去吧&lt;/p&gt;
&lt;p&gt;就这样微笑地看着自己&lt;/p&gt;
&lt;p&gt;漫步在这人生里&lt;/p&gt;
&lt;p&gt;yeah&amp;nbsp;当往事悄然走远&lt;/p&gt;
&lt;p&gt;只留下清澈的心&lt;/p&gt;
&lt;p&gt;yeah&amp;nbsp;让我们相互温暖&lt;/p&gt;
&lt;p&gt;漫步在这阳光里&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这一年我 26 周岁，自 16&amp;nbsp;岁离家求学至今，已逾十载。&lt;/p&gt;
&lt;h2&gt;结婚&lt;/h2&gt;
&lt;p&gt;这一年我结婚了。是的，如果说这一年我还算有些功业，那就是“把婚给结了吧”。结婚于我于妞，其实是件俗气难当，耗时耗财的苦差事。前几年每次我父母提到婚礼的事情，都会被我一口否决。我知道父亲的心思，一是墨守成规，二是臭显摆，三么，则是想通过我们的婚礼将以前随出去的份子钱“赚”回来。怎么说咱也是受过几年高等教育，读过几本圣贤书，有理想有追求有品味的三好有为青年，21世纪新好男人，对于这种千篇一律的所谓“婚礼”实在是不胜其烦。&lt;/p&gt;
&lt;p&gt;但是自从 13&amp;nbsp;年父亲车祸以后，他变得越发娇气，情绪反复波动，因此为了让他开心一些，在婚礼这件事上，我做了让步，而这就是我全年苦难的开始。究其原因，一是文化代沟，二是地域差异。文化代沟让我们在礼节协调上费了无数口舌，而地域差异则让我们在行程安排上耗了大把心力。&lt;/p&gt;
&lt;p&gt;我记得 14 年 2 月 14&amp;nbsp;日，情人节，一个雾霾阴布的下午，妞拉着我去北京国家会议中心挤婚博会，疲累不堪。&lt;/p&gt;
&lt;p&gt;我记得北京有个婚纱摄影基地叫温榆河，然后我们路过那里时发现其就是一条蚊子漫天的臭水沟，连杭州城内随便一条小河都比不过。&lt;/p&gt;
&lt;p&gt;我记得我们为了拍一套不错的婚纱，讲价、下单、包车，拍摄、选片，修图，前后折腾了有十个来回。&lt;/p&gt;
&lt;p&gt;我记得我们为了买几套合身的礼服，探店、量身，裁剪，定做，返工，寄送，前后又折腾了十个来回。&lt;/p&gt;
&lt;p&gt;我记得我们耗费重金买的戒指项链，到头来也不过是个摆设，长期锁在柜子里，只有回家见亲时方才穿戴。&lt;/p&gt;
&lt;p&gt;我记得 4 月份，我们带着几乎从没出过远门没坐过飞机高铁的父母，不远千里来浙拜亲。母亲好心，竟带了 30kg&amp;nbsp;的土特产一路随行，北京-&amp;gt;上海-&amp;gt;杭州-&amp;gt;台州，作为队伍里唯一的壮年劳力，我在车站弓着屁股推着箱子，亦乐亦苦？我记得在杭州地铁站，父亲踌躇良久，但就是搞不清楚出站时该把地铁票插回到哪里，弄得我哭笑不得，亦乐亦苦？我记得临行之前，他们在家里吵天闹地，要我取消行程，退订机票，我在北大未名湖畔，泪水夺框，心绪难平，亦乐亦苦？我记得行程将尽，晚餐小聚，发小作陪，父亲酒至，再起口角，惹得我心痛难当，脸面无光，破口大骂，歇斯底里，亦乐亦苦？&lt;/p&gt;
&lt;p&gt;我记得 10&amp;nbsp;月份，我们又带着妞的父母外公阿姨表弟一干人等，不远千里来冀回亲。外公年老，辛苦一生，从未去过北京拜过伟大领袖毛主席。我和妞起早贪黑，披星戴月，带着外公父母，天安门、故宫、天坛、长城、北大，不厌其烦，不胜其累，亦乐亦苦？&lt;/p&gt;
&lt;p&gt;长尊父母，谓之奈何也。&lt;/p&gt;
&lt;p&gt;我记得在婚礼当日，我们站在门口迎客，却迎来断续不绝的乞丐打着竹板过来跟我们讨喜钱&amp;#8212;原来他们也算定吉日黄道，喜事多金。&lt;/p&gt;
&lt;p&gt;亦乐亦苦？&lt;/p&gt;
&lt;p&gt;婚礼之于我们，更多是为了满足父母虚荣演一场戏罢了。现实不允许我们造一个日光倾城的大梦，我们所能做的，只是在两代亲朋、两块地域、两种风俗之间辛苦周旋，不求华丽出彩，但求顺利过关。没有新马泰蜜月旅行，没有大房子装修一新，送走所有亲朋后，我们回到杭州，回到自己租住的十几平米的小房子里，休整一天，然后她去上班，我也去上班。&lt;/p&gt;
&lt;p&gt;&lt;img src="/assets/img/2014-xibeixing-dajiaoya.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://oh-my-love.xiaohanyu.me/"&gt;所谓相行，即是人生&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;工作&lt;/h2&gt;
&lt;p&gt;这一年，工作上依然是散漫无边，除了仰仗朋友介绍一些私活赚了点养家糊口的钱，几乎毫无建树。年底曾短暂加入一个创业团队负责人员招聘技术选型等初期工作，但是最终一败涂地，悻悻退出。工作几年来，我一直努力在 DevOps, Web Framework, Programming Languages&amp;nbsp;方面广泛涉猎，力求融汇兼通&amp;#8212;尚不敢妄想“贯通”一词。一方面，我并不想过早地把自己的职业规划限定于一个狭窄的领域内，另一方面，我常常能在广泛的阅读和跨领域的思考中迸发出很多灵感，这带给我很多的快乐。&lt;/p&gt;
&lt;p&gt;就我个人而言，我发现自己很难在某一方面成为顶尖，比如编程，我根本就不是一个顶尖的算法工程师或系统工程师；比如设计，我恐怕也只是刚刚入了前端开发的门；再如写作，我写的东西无非是自我记录日常反省，尚无他长。我的专长可能在于，我可以将这几方面融合，并以工程师的耐心配以变通，调教出一些还不错的成果。&lt;/p&gt;
&lt;p&gt;说到底， &lt;strong&gt;手艺人，耐心和变通乃生身立命之本。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;You literally ought to be asking yourself all the time what is the most important thing in the world I could be working on right now, and if you are not working on that why aren&amp;#8217;t&amp;nbsp;you?&amp;quot;&lt;/p&gt;
&lt;p&gt;&amp;#8212; &lt;a href="https://en.wikipedia.org/wiki/Taren_Stinebrickner-Kauffman"&gt;Taren Stinebrickner-Kauffman&lt;/a&gt; describing her partner, &lt;a href="https://en.wikipedia.org/wiki/Aaron_Swartz"&gt;Aaron&amp;nbsp;Swartz&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;专业方面，这一年在 Clojure/Haskell/Ruby/JavaScript 方面均有所涉猎，但是所研甚浅，并且尚无机会加以实践，因此所得有限；前半年花了很多时间在系统性地学习前端开发和字体设计的一些基础知识，最终总算能用 Bootstrap 做出还算过得去的网站（比如本博客）；后半年曾花了很长时间思考实践 &lt;span class="caps"&gt;HTTP&lt;/span&gt; RESTful &lt;span class="caps"&gt;API&lt;/span&gt; 的设计以及前后端的对接实现，这方面倒是颇有心得。 Open Source 方面，我依旧在很好地维护着 &lt;a href="https://github.com/xiaohanyu/oh-my-emacs"&gt;oh-my-emacs&lt;/a&gt; ，目前 oh-my-emacs 已经是世界上最好的 dotemacs 项目之一，并在全球范围内逐渐形成了自己的用户群。有几次我去 Github 上处理 issues，却发现 oh-my-emacs 用户之间已经讨论完毕并给出了很好的解决方案，我所能做的就是将用户的讨论提炼精简，写在 oh-my-emacs&amp;nbsp;里面。可见即便是一个原理很简单的项目，将其做到极致，或许也会有莫大的价值。&lt;/p&gt;
&lt;h2&gt;阅读&lt;/h2&gt;
&lt;p&gt;这一年读书很少，很多技术书只读到一半就读不下去了，究其原因，是自己的基础不足，想深入却碰到了自己的瓶颈。在前面几年的学习中，我更多关注的是工具框架方面的知识，而对基础原理方面的知识关注有限。我想，一项工具一门框架的学习可能只需要几周，但是一门理论基础往往需要几年的坚持。因此在新的一年，我会将更多的时间投入到基础理论的学习中去。顺便，还是推荐下 14&amp;nbsp;年读过并觉得不错的书籍吧：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《&lt;a href="http://book.douban.com/subject/6518605/"&gt;地球往事&lt;/a&gt;》：&amp;nbsp;有人说，读完三体，再抬头看星空，感觉就不一样了，嗯，是这样的&lt;/li&gt;
&lt;li&gt;《&lt;a href="http://book.douban.com/subject/20507206/"&gt;众病之王&lt;/a&gt;》：&amp;nbsp;“永生带来的是死亡”，非常精彩的关于癌症的科普书&lt;/li&gt;
&lt;li&gt;《&lt;a href="http://book.douban.com/subject/1076685/"&gt;李鸿章传&lt;/a&gt;》：&amp;nbsp;“天下唯庸人无咎无誉”，任公笔力磅薄，目光如炬，世间奇才&lt;/li&gt;
&lt;li&gt;《&lt;a href="http://book.douban.com/subject/7067916/"&gt;施瓦辛格健身全书&lt;/a&gt;》：&amp;nbsp;“行走的解剖模型”，极好的健身教程&lt;/li&gt;
&lt;li&gt;《&lt;a href="http://book.douban.com/subject/25717097/"&gt;囚徒健身&lt;/a&gt;》：&amp;nbsp;也是极好的健身书，适合不方便去健身房的朋友&lt;/li&gt;
&lt;li&gt;《&lt;a href="http://book.douban.com/subject/3554091/"&gt;钱途&lt;/a&gt;》：&amp;nbsp;极好的关于风险投资行业的科普扫盲书&lt;/li&gt;
&lt;li&gt;《&lt;a href="http://book.douban.com/subject/20507578/"&gt;The Healthy Programmer&lt;/a&gt;》：&amp;nbsp;程序员健康指南书&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;一路向西&lt;/h2&gt;
&lt;p&gt;这一年年中，我和妞两个人，手里攥着 16&amp;nbsp;张火车票，千山万水，从太原、平遥，到延安、西安，到张掖、敦煌，一路向西，转了好大一圈。&lt;/p&gt;
&lt;p&gt;&lt;img src="/assets/img/2014-xibeixing-binggou.jpg" alt="oh my love" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="/assets/img/2014-xibeixing-jiayuguan.jpg" alt="嘉峪关" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;毕业季&lt;/p&gt;
&lt;p&gt;他们终将离开呆了三年的北京&lt;/p&gt;
&lt;p&gt;“去趟大西北吧”&lt;/p&gt;
&lt;p&gt;“好哇”&lt;/p&gt;
&lt;p&gt;一周后&lt;/p&gt;
&lt;p&gt;手握十六张火车票&lt;/p&gt;
&lt;p&gt;他们再次踏上征途&lt;/p&gt;
&lt;p&gt;太原街头&lt;/p&gt;
&lt;p&gt;胡同里飘出来的芬芳醋香&lt;/p&gt;
&lt;p&gt;平遥夜色&lt;/p&gt;
&lt;p&gt;王家大院&lt;/p&gt;
&lt;p&gt;壶口奇遇&lt;/p&gt;
&lt;p&gt;红色延安&lt;/p&gt;
&lt;p&gt;不变的革命老区&lt;/p&gt;
&lt;p&gt;古色西安&lt;/p&gt;
&lt;p&gt;壮观的秦皇兵俑&lt;/p&gt;
&lt;p&gt;钟鼓相望&lt;/p&gt;
&lt;p&gt;老友相伴&lt;/p&gt;
&lt;p&gt;“劝君更进一杯酒，西出阳关无故人”&lt;/p&gt;
&lt;p&gt;丹霞&lt;/p&gt;
&lt;p&gt;五彩斑斓&lt;/p&gt;
&lt;p&gt;天下奇观&lt;/p&gt;
&lt;p&gt;冰沟&lt;/p&gt;
&lt;p&gt;踏上观景台的那一刻&lt;/p&gt;
&lt;p&gt;蓝天&lt;/p&gt;
&lt;p&gt;白云&lt;/p&gt;
&lt;p&gt;雪山&lt;/p&gt;
&lt;p&gt;两个傻孩子&lt;/p&gt;
&lt;p&gt;在大西北的空旷浩远面前&lt;/p&gt;
&lt;p&gt;忘乎所以&lt;/p&gt;
&lt;p&gt;敦煌&lt;/p&gt;
&lt;p&gt;莫高窟&lt;/p&gt;
&lt;p&gt;鸣沙月泉&lt;/p&gt;
&lt;p&gt;大漠孤烟&lt;/p&gt;
&lt;p&gt;铁马秋风&lt;/p&gt;
&lt;p&gt;楼般夜雪&lt;/p&gt;
&lt;p&gt;此行将尽&lt;/p&gt;
&lt;p&gt;尽在嘉峪关头&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;离京回杭&lt;/h2&gt;
&lt;p&gt;西北归来，两个人马上着手离京回杭事宜。在京北漂三年，事情完成的不多，行李却积攒不少。两个人花了整整三天的时间才将所有行李打包完毕，最终花了 1000 大洋，寄了 600kg&amp;nbsp;的行李到杭州。而彼时我们还没有到杭州找房子，因此想了个折衷的办法，先把行李寄到同事家，再转运到租住的地方。当然，这次我们希望物流可以慢一些，最好等我们找好房子后直接转送到新的住处。所幸，我们最终也是这么做的。&lt;/p&gt;
&lt;p&gt;北漂三年，一事无成。韶华已逝，岁月蹉跎，彷徨岁月，且行且思。&lt;/p&gt;
&lt;p&gt;在京三年，全职工作不到两年，闲散飘荡一年有余，刚好赚够了养家糊口的钱，离京时已所剩不多；经历了运维测试研发各种工作，也接触到了大小不一风格迥异的团队；学会了 functional programming 的基本思想；学会了基本的 web 开发；精通 git 和 github ，有了自己的 open source 项目并维护至今；读书，各种书籍大约 200&amp;nbsp;余本；帮助家里处理了各种各样的杂事。&lt;/p&gt;
&lt;p&gt;在京三年，由于妞的缘故，基本上生活还是没有脱离学校的圈子。想起来，吃北大的食堂，看讲堂的电影，走未名的小路，泡北大的研究妞，还是蛮幸福的，哈。&lt;/p&gt;
&lt;p&gt;无可否认，就互联网行业的资源和机会而言，北京确实是首屈一指；但是我和妞就是不喜欢北京那股围绕户口所建立起来的各种壁垒和优越感；就是不喜欢北京那种以牺牲周边地区利益换取自身发展的模式；就是不喜欢北京冬天那看不清扫不尽的雾霾；就是不喜欢北京那脏兮兮的马路牙子；就是不喜欢北京那不相配套的基础设施服务。&lt;/p&gt;
&lt;p&gt;我想我们应该不会再回到北京。世界这么大，没有必要为了所谓户口将自己的大好青春耗在一个城市。&lt;/p&gt;
&lt;p&gt;14 年 7 月 1 日，我和妞告别了北大的师长同学，高铁 5&amp;nbsp;个小时到达阴雨绵绵的杭州。次日，在某家星级酒店的顶层餐厅，俯瞰钱塘吃好早餐后，妞就去上班了。&lt;/p&gt;
&lt;p&gt;她直接被分配到杭州郊区的工地，发了安全帽和安全鞋。&lt;/p&gt;
&lt;p&gt;这让我们产生了极强的虚空感。&lt;/p&gt;
&lt;p&gt;“再见，北京”。&lt;/p&gt;
&lt;p&gt;&lt;img src="/assets/img/2012-beijing-zhiwuyuan.jpg" /&gt;&lt;/p&gt;
&lt;h2&gt;健身&lt;/h2&gt;
&lt;p&gt;大概是从 13&amp;nbsp;年底，我开始被持续不断的肩颈背痛所困扰。酸痛倒是其次，主要是影响自己的工作学习效率，让我颇为恼火。因此离京回杭后下定决心开始锻炼，理论和实践双管齐下，坚持半年有余，总算有所控制。&lt;/p&gt;
&lt;p&gt;想来还是北京三年过于闷宅，锻炼有限，得此报应。好在事情尚未进展到不可逆转的地步。不过慢性病的特点在于发病慢，恢复也慢。因此要想完全恢复，怕是要打场持久战。&lt;/p&gt;
&lt;p&gt;工科男做事的方法就是工程化&amp;#8212;调研、规划、对比，方方面面考虑周全。为了控制病痛恢复健康， 14&amp;nbsp;年下半年主要在如下方面做了很多努力：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统性地学习基础健身知识，阅读完成了 3&amp;nbsp;本入门的健身书籍&lt;/li&gt;
&lt;li&gt;7 - 9&amp;nbsp;月份系统性地进行家中无器械健身训练，循序渐进，对比效果&lt;/li&gt;
&lt;li&gt;10 - 12 月份工作期间，购置 &lt;a href="http://www.amazon.com/Logitech-910-001799-M570-Wireless-Trackball/dp/B0043T7FXE"&gt;Dahon &lt;span class="caps"&gt;SP8&lt;/span&gt;&lt;/a&gt; 折叠车，每天骑行，双程 25km&amp;nbsp;，通勤锻炼。&lt;/li&gt;
&lt;li&gt;购置 &lt;a href="http://ergohuman.com/ergohuman-chair-me7erg-high-back-with-headrest-and-mesh/"&gt;Ergohuman&lt;/a&gt; 人体工学座椅， &lt;a href="http://item.jd.com/1242699109.html"&gt;ThinkWise s100&lt;/a&gt;&amp;nbsp;显示器支架&lt;/li&gt;
&lt;li&gt;购置 &lt;a href="http://www.logitech.com/en-us/product/wireless-trackball-m570"&gt;Logitech &lt;span class="caps"&gt;M570&lt;/span&gt;&lt;/a&gt;&amp;nbsp;轨迹球鼠标，缓解鼠标手&lt;/li&gt;
&lt;li&gt;购置简易升降桌，尝试站立式办公&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这种全方位立体化多角度的打击下，我的肩颈背痛总算有所收敛。在此奉劝各位程序员朋友，工作失去随时找，健康失去不再来。有时间我会再写一篇《程序员健康指南》，记录下我在这方面的心得。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Imagine life as a game in which you are juggling some five balls in the air. You name them&amp;#8212;work, family, health, friends and spirit&amp;#8212;and you&amp;#8217;re keeping all of these in the air. You will soon understand that work is a rubber ball. If you drop it, it will bounce back. But the other four balls&amp;#8212;family, health, friends and spirit&amp;#8212;are made of glass. If you drop one of these, they will be irrevocably scuffed, marked, nicked, damaged or even shattered. They will never be the same. You must understand that and strive for balance in your&amp;nbsp;life.&lt;/p&gt;
&lt;p&gt;&amp;#8212; &lt;a href="https://en.wikipedia.org/wiki/Brian_Dyson"&gt;Brian&amp;nbsp;Dyson&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;养猫&lt;/h2&gt;
&lt;p&gt;14 年 9&amp;nbsp;月份，趁妞出差之际，我领养了两只两个月大的三花小母猫，成了一名光荣的铲屎大将军。不出所料，它们带给了我很多乐趣，陪我度过了一个个灯下漫笔的“寂寞”时光，谓之为程序员的好伴侣，一点也不为过。我和妞给它们取了名字，分别叫“小木”和“小鱼”，此乃大名，而生活中我们则直接呼之为“大臭臭”和“小臭臭”。&lt;/p&gt;
&lt;p&gt;说实话，两只土猫长得并不好看，远逊于纯种猫；其中那只小臭猫，长得尤其丑，又丑、又臭、又馋、又笨、又胆小，并且还总是莫名其妙地受伤。最开始我们一点也不喜欢它。可是看它那臭笨滑稽楚楚可怜的样子看得多了以后，也就默默认可了它。&lt;/p&gt;
&lt;p&gt;妞本来是反对我养猫的，嫌麻烦。但是精诚所致金石为开，当我负担了所有的铲屎工作和卫生清洁后，妞也就默许了。再后来生活日久，感情日深，一家人总算其乐融融。每个寂静的夜，读书写码，一妞二喵相伴，常让我有“生活惬意如此，夫复何求”的感慨。每天晨光初现，两只喵就会在你耳边，徘徊盘旋，逮住机会就亲你一口，呼呼呼呼地把你弄醒&amp;#8212;当然，我睡得沉，经常毫无知觉，而妞则经常被亲醒，无可奈何。&lt;/p&gt;
&lt;p&gt;我自称为猫“爸爸”，称妞为猫“妈妈”，有时“爸爸妈妈”地叫得频繁，妞就问我是不是真想“封山育林，播种造人”了，我但莞尔。半年多来，我负责它们饮食起居，给它们洗澡上药，逗它们开心，也喝止它们惹祸，细想起来，还真和养个孩子差不多呢。&lt;/p&gt;
&lt;p&gt;&lt;img src="/assets/img/2014-cat.jpg" alt="小木和小鱼" /&gt;&lt;/p&gt;
&lt;h2&gt;散财&lt;/h2&gt;
&lt;p&gt;这一年依然保持着不间断的 donation&amp;nbsp;习惯。&lt;/p&gt;
&lt;p&gt;13 年的时候我曾经每个月向我喜欢的 Free/Open Source 软件捐钱（每次 100rmb 左右），这样大概捐助了 Emacs/Vim/&lt;span class="caps"&gt;KDE&lt;/span&gt; 等，捐了七、八次后发现可捐的软件不多，因此今年年中开始向 Wikipedia 捐钱，每个月 5 美金，折合每天 1rmb 。除此之外，每月定向捐助 100rmb&amp;nbsp;。&lt;/p&gt;
&lt;p&gt;Money comes and&amp;nbsp;goes.&lt;/p&gt;
&lt;h2&gt;买车&lt;/h2&gt;
&lt;p&gt;14 年 8 月，由于妞的工作需要，我们购置了一辆 Ford Focus&amp;nbsp;。这是意料之外的事情。很惭愧，我们手头的钱远远不够，因此最终还是在借了家里的赞助。老实说，我和妞都不愿意向家里开口。即便是婚礼，我们也是自己负担了大部分的礼服、摄影等费用。&lt;/p&gt;
&lt;p&gt;说到底，我们只是不想因为金钱的缘故在自由方面向长辈妥协。我们的父母眼界过于狭窄，总是想着要把子女留在自己身边，努力赚钱为子女准备房车、铺好一条在他们看来金光闪闪的人生大道，同时也把自己后半生的幸福全部压在子女身上。&lt;/p&gt;
&lt;p&gt;而这无形之中带给了我们相当大的心理压力。因此不到万不得已，我们不会向父母开口。&lt;/p&gt;
&lt;p&gt;这次买车是刚需。一方面，妞的工作性质决定每天上下班要 30km&amp;nbsp;，并且经常要到处出差，另一方面，买车之后公司提供的补助也足够我们负担养车的所有费用并能有点结余。&lt;/p&gt;
&lt;p&gt;Anyway, 有车之后望着天窗听雨打在车顶上的声音，感觉还是很不错的。跨年夜，当我们开着车在夜黑风高空无一车的高速公路上急驰时，我们未曾意识到， &lt;strong&gt;彼时此刻，不经意间，我们都已长大成人，要开始新的征程了&lt;/strong&gt;&amp;nbsp;。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <id>tag:xiaohanyu.me,2014-07-26:/2014/07/25/build-static-site-with-nanoc-2/</id>
    <title type="html">Build Static Site with Nanoc (II)</title>
    <published>2014-07-25T20:00:00Z</published>
    <updated>2014-07-25T20:00:00Z</updated>
    <link rel="alternate" href="http://xiaohanyu.me/2014/07/25/build-static-site-with-nanoc-2/"/>
    <content type="html">&lt;p&gt;&lt;a href="http://xiaohanyu.me/2014/05/04/build-static-site-with-nanoc-1/"&gt;上篇&lt;/a&gt;主要讲了用 nanoc 来构建一个 static site 的基本原理，这一篇专注于这个 blog&amp;nbsp;本身的一些设计。&lt;/p&gt;
&lt;h2&gt;Bootstrap&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://getbootstrap.com/"&gt;Bootstrap&lt;/a&gt; 现在大概已经成为像我一样的半吊子前端写网站的标配了吧，简单，明了，快捷，简直是为我这种人量身定做的。最开始我也是想一切自己动手，奈何还是没有禁住 Bootstrap 各种漂亮主题及插件的诱惑，最终还是不能免俗，从了 Bootstrap&amp;nbsp;。&lt;/p&gt;
&lt;p&gt;其实类似于 Bootstrap 的前端框架还是有一些的，比如 &lt;a href="http://foundation.zurb.com/"&gt;Foundation&lt;/a&gt; 和 &lt;a href="http://semantic-ui.com/"&gt;Semantic &lt;span class="caps"&gt;UI&lt;/span&gt;&lt;/a&gt; 。 Semantic &lt;span class="caps"&gt;UI&lt;/span&gt; 甚至在其官方主页上指出了 Bootstrap 命名规则的混乱。不过 Bootstrap 最大的优势在于它的普及(&lt;del&gt;烂大街&lt;/del&gt;)，这种普及甚至使得 Bootstrap&amp;nbsp;成了一个平台。&lt;/p&gt;
较好的 Bootstrap&amp;nbsp;主题和模板：
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://startbootstrap.com/" class="uri"&gt;http://startbootstrap.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wrapbootstrap.com/" class="uri"&gt;https://wrapbootstrap.com/&lt;/a&gt;&amp;nbsp;，很多收费&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.blacktie.co/" class="uri"&gt;http://www.blacktie.co/&lt;/a&gt; ，似乎是由个人设计师设计维护的 Bootstrap&amp;nbsp;主题站，质量都很不错&lt;/li&gt;
&lt;li&gt;&lt;a href="http://bootswatch.com/" class="uri"&gt;http://bootswatch.com/&lt;/a&gt; ，免费的 &lt;span class="caps"&gt;CSS&lt;/span&gt; 主题文件，使用简单，替换原有 Bootstrap 的 &lt;span class="caps"&gt;CSS&lt;/span&gt;&amp;nbsp;文件即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外， &lt;a href="http://bootsnipp.com/"&gt;Bootsnipp&lt;/a&gt; 提供了非常全面的各种有用的基于 Bootstrap 的 code snippets 和设计元素。本 blog 的 timeline 类型的 Archives&amp;nbsp;页面就来源于此。&lt;/p&gt;
&lt;h2&gt;&lt;span class="caps"&gt;JS&lt;/span&gt;/&lt;span class="caps"&gt;CSS&lt;/span&gt;&amp;nbsp;compress&lt;/h2&gt;
&lt;p&gt;&lt;span class="caps"&gt;JS&lt;/span&gt;/&lt;span class="caps"&gt;CSS&lt;/span&gt; compress/minify 应该是前端开发的基本常识了。 nanoc 中提供了 &lt;a href="http://nanoc.ws/docs/api/Nanoc/Filters/Rainpress.html"&gt;rainpress&lt;/a&gt; 和 &lt;a href="http://nanoc.ws/docs/api/Nanoc/Filters/UglifyJS.html"&gt;uglify_js&lt;/a&gt; 两个 filter，分别用于 &lt;span class="caps"&gt;CSS&lt;/span&gt; 和 &lt;span class="caps"&gt;JS&lt;/span&gt; 文件的压缩。但实际中，我们往往会有多个 &lt;span class="caps"&gt;JS&lt;/span&gt;/&lt;span class="caps"&gt;CSS&lt;/span&gt; 文件，而我们希望能将其压缩成单个 &lt;span class="caps"&gt;JS&lt;/span&gt;/&lt;span class="caps"&gt;CSS&lt;/span&gt; 文件。这方面 nanoc 没有提供内置的解决方案。好在 Google 是万能的，完美的&lt;a href="http://jakoblaegdsmand.com/blog/2012/12/minifying-js-and-css-in-nanoc/"&gt;解决方案&lt;/a&gt;也是存在的，感谢 &lt;a href="http://jakoblaegdsmand.com/"&gt;Jakob&lt;/a&gt;&amp;nbsp;。&lt;/p&gt;
&lt;p&gt;Jakob 的 blog 写得浅显易懂，其主要的优点是可以通过 &lt;code&gt;nanoc.yml&lt;/code&gt; 中的 &lt;code&gt;debug&lt;/code&gt; 选项来启停 &lt;span class="caps"&gt;JS&lt;/span&gt;/&lt;span class="caps"&gt;CSS&lt;/span&gt;&amp;nbsp;的压缩。具体的原理和代码我就不再这里重复了，看博文吧。&lt;/p&gt;
&lt;h2&gt;nanoc-cachebuster&lt;/h2&gt;
&lt;p&gt;我们已经解决了 &lt;span class="caps"&gt;JS&lt;/span&gt;/&lt;span class="caps"&gt;CSS&lt;/span&gt; 的压缩问题，还差一步，就可以形成 nanoc static site frontend 的完美解决方案，那就是我们离不开的 cache 。这个 cache 主要是浏览器端的 cache 。Cache 是个好东西，只是有时会给开发人员造成一些小麻烦。比如我们修改 &lt;span class="caps"&gt;JS&lt;/span&gt;/&lt;span class="caps"&gt;CSS&lt;/span&gt; 文件并且 push 到“线上”的时候，在一定时间段内浏览器并不会请求最新的 &lt;span class="caps"&gt;JS&lt;/span&gt;/&lt;span class="caps"&gt;CSS&lt;/span&gt; 文件，而是会使用已有的尚未过期的 cache 中的 &lt;span class="caps"&gt;JS&lt;/span&gt;/&lt;span class="caps"&gt;CSS&lt;/span&gt; 文件，这就使得我们没有办法实时地看到 &lt;span class="caps"&gt;JS&lt;/span&gt;/&lt;span class="caps"&gt;CSS&lt;/span&gt; 修改后的前端效果。解决方案就是在开发时绕过 cache ，让浏览器每次都请求最新的 &lt;span class="caps"&gt;JS&lt;/span&gt;/&lt;span class="caps"&gt;CSS&lt;/span&gt; 文件。这有两种办法，一是在浏览器端，可以强制刷新或者直接禁用浏览器的 cache ，但是这种方案的局限性在于，每种浏览器都有自己的设置方法，并且做为开发人员，你没有办法保证你的用户都禁用 cache ；第二种办法就是在服务器端做一些手脚，这就是 &lt;a href="http://webassets.readthedocs.org/en/latest/expiring.html"&gt;cache busting&lt;/a&gt;&amp;nbsp;。&lt;/p&gt;
&lt;p&gt;Cache busting 的原理是每次修改 &lt;span class="caps"&gt;JS&lt;/span&gt;/&lt;span class="caps"&gt;CSS&lt;/span&gt; 文件后，通过在 &lt;span class="caps"&gt;JS&lt;/span&gt;/&lt;span class="caps"&gt;CSS&lt;/span&gt; 的文件名上加入一个版本号或者类似的手段，来保证浏览器请求的都是最新的 &lt;span class="caps"&gt;JS&lt;/span&gt;/&lt;span class="caps"&gt;CSS&lt;/span&gt; 文件，这样就能确保 &lt;span class="caps"&gt;JS&lt;/span&gt;/&lt;span class="caps"&gt;CSS&lt;/span&gt; 的效果能够实时地起到作用。 Nanoc 有一个 &lt;a href="http://avdgaag.github.io/nanoc-cachebuster/"&gt;nanoc-cachebuster&lt;/a&gt; ，其作者写了一篇详细的 &lt;a href="http://arjanvandergaag.nl/blog/nanoc-cachebuster.html"&gt;post&lt;/a&gt; 来阐述 nanoc-cachebuster&amp;nbsp;的实现原理，我就不再多言了。&lt;/p&gt;
&lt;h2&gt;Font&amp;nbsp;Selection&lt;/h2&gt;
&lt;p&gt;就观感上来讲，除了基本的版面设计，字体选择是第二重要的因素。你至少要知道&lt;a href="http://zh.wikipedia.org/wiki/%25E8%25A1%25AC%25E7%25BA%25BF%25E4%25BD%2593"&gt;衬线字体&lt;/a&gt;和&lt;a href="http://zh.wikipedia.org/wiki/%25E6%2597%25A0%25E8%25A1%25AC%25E7%25BA%25BF%25E4%25BD%2593"&gt;无衬线字体&lt;/a&gt;的基本概念。而在 Web 上应用这些概念，你还需要了解一些有关以 &lt;a href="http://en.wikipedia.org/wiki/Web_typography"&gt;web font&lt;/a&gt; 的一些知识。关于这点我就不展开写了，任何一本不错的 &lt;span class="caps"&gt;CSS&lt;/span&gt; 书籍都会用一章的内容来详细讲解字体以及 web font 的概念。我个人的选择是 &lt;a href="https://www.google.com/fonts/specimen/Lora"&gt;Lora&lt;/a&gt; ，灵感来自于 &lt;a href="http://bootswatch.com/readable/"&gt;bootswatch readable theme&lt;/a&gt;&amp;nbsp;。&lt;/p&gt;
&lt;p&gt;这里还有两个小技巧，和大家分享。一是在 &lt;span class="caps"&gt;CSS&lt;/span&gt; 中，字体的样式是依照 &lt;code&gt;font-family&lt;/code&gt;&amp;nbsp;的值以及相应的字体本身的特性决定的。比如：&lt;/p&gt;
&lt;pre class="sourceCode css"&gt;&lt;code class="sourceCode css"&gt;body &lt;span class="kw"&gt;{&lt;/span&gt;
  &lt;span class="kw"&gt;background-color:&lt;/span&gt; &lt;span class="dt"&gt;#ffffff&lt;/span&gt;&lt;span class="kw"&gt;;&lt;/span&gt;
  &lt;span class="kw"&gt;font-family:&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;Lora&amp;#39;&lt;/span&gt;, Georgia, &lt;span class="st"&gt;&amp;#39;Times New Roman&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;SimSun&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;Microsoft YaHei&amp;#39;&lt;/span&gt;, &lt;span class="dt"&gt;serif&lt;/span&gt;&lt;span class="kw"&gt;;&lt;/span&gt;
&lt;span class="kw"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里指定 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 的字体为 Lora ，但是 Lora 本身是一款英文字体，对于汉字是“无能为力”的，因此如果 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 中有汉字的话，浏览器会按照 &lt;code&gt;font-family&lt;/code&gt; 所指定的值依次找下去，直到找到一款从 web 上加载的或者系统中已经存在的汉字字体。另外，在 Chrome 和 Firefox 的 Developer Tools 中可以看到浏览器渲染页面时所使用的字体的细节，具体参考 &lt;a href="http://stackoverflow.com/questions/884177/how-can-i-determine-what-font-a-browser-is-actually-using-to-render-some-text"&gt;StackOverflow&lt;/a&gt;&amp;nbsp;。&lt;/p&gt;
&lt;h2&gt;Third-party&amp;nbsp;Plugins&lt;/h2&gt;
&lt;p&gt;由于静态站点本身并没有数据库之类的标配的本地存储，因此像评论、站内搜索，以及统计这类功能需要借助第三方的服务。站内搜索比较简单，直接调用 Google 的 &lt;code&gt;site:xiaohanyu.me&lt;/code&gt;&amp;nbsp;搜索即可：&lt;/p&gt;
&lt;pre class="sourceCode html"&gt;&lt;code class="sourceCode html"&gt;&lt;span class="kw"&gt;&amp;lt;form&lt;/span&gt;&lt;span class="ot"&gt; class=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;form-inline&amp;quot;&lt;/span&gt;&lt;span class="ot"&gt; target=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;_blank&amp;quot;&lt;/span&gt;&lt;span class="ot"&gt; method=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;get&amp;quot;&lt;/span&gt;&lt;span class="ot"&gt; action=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;http://google.com/search&amp;quot;&lt;/span&gt;&lt;span class="kw"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="kw"&gt;&amp;lt;input&lt;/span&gt;&lt;span class="ot"&gt; type=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;hidden&amp;quot;&lt;/span&gt;&lt;span class="ot"&gt; value=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;site:xiaohanyu.me&amp;quot;&lt;/span&gt;&lt;span class="ot"&gt; name=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;q&amp;quot;&lt;/span&gt;&lt;span class="kw"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="kw"&gt;&amp;lt;input&lt;/span&gt;&lt;span class="ot"&gt; type=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;text&amp;quot;&lt;/span&gt;&lt;span class="ot"&gt; class=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;form-control pull-left&amp;quot;&lt;/span&gt;&lt;span class="ot"&gt; placeholder=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;Search&amp;quot;&lt;/span&gt;&lt;span class="ot"&gt; name=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;q&amp;quot;&lt;/span&gt;&lt;span class="kw"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kw"&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至于评论系统，我用的也就是现今最流行的第三方评论系统 &lt;a href="https://disqus.com/"&gt;Disqus&lt;/a&gt; 了。其安装设置非常简单，不再赘述。使用体验也不错。但是由于国内网络的原因， Disqus 加载的时候还是需要 2-4 秒的时间，因此我写了个 &lt;span class="caps"&gt;JS&lt;/span&gt; 函数，来按需加载 Disqus 评论。与此同时，我还在每篇 post 的 metadata 里面设置了新的属性： &lt;code&gt;disable_disqus&lt;/code&gt; ，这样如果 &lt;code&gt;disable_disqus&lt;/code&gt; 为真，那么相应的 post&amp;nbsp;就是禁用评论的。&lt;/p&gt;
&lt;p&gt;最后就是站点统计，最简单的就是传统 Blog 上的网站访问计数。这个我用的是 &lt;a href="http://www.google.com/analytics/"&gt;Google Analytics&lt;/a&gt;&amp;nbsp;，很强大，安装配置也很简单，同样不再赘述。&lt;/p&gt;
&lt;h2&gt;Atom/Sitemap/Robots.txt&lt;/h2&gt;
&lt;p&gt;除了以上，一个有节操有品味的网站还应该配备 atom/sitemap/robots.txt 。在 nanoc 中，这三种的解决方案是差不多的。以 atom 为例， nanoc3 内置的 &lt;a href="http://nanoc.ws/docs/api/Nanoc/Helpers/Blogging.html"&gt;Blogging&lt;/a&gt; 辅助模块提供了基本的 atom 生成函数 &lt;a href="http://nanoc.ws/docs/api/Nanoc/Helpers/Blogging.html#atom_feed-instance_method"&gt;atom_feed&lt;/a&gt; ，我们需要做的就是动态创建一个 nanoc item ，而这个 item 的任务就是生成实际的 &lt;code&gt;atom.xml&lt;/code&gt; 文件。 nanoc 支持 &lt;a href="http://nanoc.ws/docs/basics/"&gt;preprocess&lt;/a&gt; ，我们可以在 nanoc compile&amp;nbsp;之前做一些准备工作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Rules&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="sourceCode ruby"&gt;&lt;code class="sourceCode ruby"&gt;preprocess &lt;span class="kw"&gt;do&lt;/span&gt;
  create_github_cname
  create_robots_txt
  create_sitemap
  create_atom
&lt;span class="kw"&gt;end&lt;/span&gt;

compile &lt;span class="ot"&gt;%r{/sitemap/|/atom/|/robots/}&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;
  filter &lt;span class="st"&gt;:erb&lt;/span&gt;
&lt;span class="kw"&gt;end&lt;/span&gt;

route &lt;span class="ot"&gt;%r{/sitemap/|/atom/}&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;
  item.identifier.chop + &lt;span class="st"&gt;&amp;#39;.xml&amp;#39;&lt;/span&gt;
&lt;span class="kw"&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;create_atom&lt;/code&gt; 函数中，我们动态创建一个 &lt;a href="http://nanoc.ws/docs/api/Nanoc/Item.html"&gt;nanoc item&lt;/a&gt; （所谓动态创建的 item 就是这个 item 在实际的文件系统中没有相对应的文件）。这样的 preprocess 之后， nanoc compile 会按照指定的规则来处理生成 atom 的 item ，最终生成所需的 &lt;code&gt;atom.xml&lt;/code&gt;&amp;nbsp;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lib/preprocessors.rb&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="sourceCode ruby"&gt;&lt;code class="sourceCode ruby"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; create_atom
  content = &amp;lt;&amp;lt;&lt;span class="kw"&gt;EOS&lt;/span&gt;
&lt;span class="ot"&gt;&amp;lt;%= atom_feed \&lt;/span&gt;
&lt;span class="ot"&gt;:title =&amp;gt; &amp;#39;#{@site&lt;/span&gt;.config[&lt;span class="st"&gt;:meta_data&lt;/span&gt;][&lt;span class="st"&gt;:title&lt;/span&gt;]&lt;span class="ot"&gt;}&amp;#39;,&lt;/span&gt;
&lt;span class="ot"&gt;:author_name =&amp;gt; &amp;#39;#{@site&lt;/span&gt;.config[&lt;span class="st"&gt;:meta_data&lt;/span&gt;][&lt;span class="st"&gt;:author&lt;/span&gt;]&lt;span class="ot"&gt;}&amp;#39;,&lt;/span&gt;
&lt;span class="ot"&gt;:author_uri =&amp;gt; &amp;#39;#{@site&lt;/span&gt;.config[&lt;span class="st"&gt;:base_url&lt;/span&gt;]&lt;span class="ot"&gt;}&amp;#39;,&lt;/span&gt;
&lt;span class="ot"&gt;:limit =&amp;gt; 10 %&amp;gt;&lt;/span&gt;
&lt;span class="ot"&gt;EOS&lt;/span&gt;

&lt;span class="ot"&gt;  @items &amp;lt;&amp;lt; Nanoc3::Item.new(content,&lt;/span&gt;
&lt;span class="ot"&gt;                             {:extension =&amp;gt; &amp;#39;xml&amp;#39;, :is_hidden =&amp;gt; true},&lt;/span&gt;
&lt;span class="ot"&gt;                             &amp;#39;/atom/&amp;#39;)&lt;/span&gt;
&lt;span class="ot"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Cute&amp;nbsp;Things&lt;/h2&gt;
&lt;p&gt;除此之外，我还设计了一些有趣的小东西，当然，如果您是资深的前端工程师，那么可以直接忽略这一节，我怕班门弄斧，贻笑大方。&lt;/p&gt;
&lt;p&gt;一是我给每篇 post 加上了 next 和 previous 的 link button， &lt;del&gt;当然如果有一天我的文章写的足够好能让人流连忘返的话&lt;/del&gt; ，这两个 button 或许是有用的。具体的技术细节可以参考 &lt;a href="https://ecarmi.org/writing/next-previous-links-nanoc/"&gt;这里&lt;/a&gt;&amp;nbsp;。&lt;/p&gt;
&lt;p&gt;二是我在页面上加了一个 &lt;strong&gt;back-to-top&lt;/strong&gt; 的 button ，这样在页面滚了一点进度时， back-to-top button 会出现在右下角，然后你可以点击这个 button&amp;nbsp;回到页面的最顶端。&lt;/p&gt;
&lt;p&gt;三是我参考一些成型的设计，给自己的 blog 设计了一个还算满意的 &lt;a href="http://xiaohanyu.me/does-not-exist"&gt;404 page&lt;/a&gt;&amp;nbsp;。&lt;/p&gt;
&lt;p&gt;最后，我在 &lt;a href="http://wxiaohanyu.me/about/index.html"&gt;about page&lt;/a&gt; 中加入了一些 random quotes 的小把戏，这样每次访问/刷新 about page 的时候，你看到的 quotes 都是随机的。至于原理，暂且不表 ^_^&amp;nbsp;。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;以上，大概记录了我个人建站的基本过程，从基本的技术选型，到版式字体的设计，以及一些 nanoc&amp;nbsp;的小技巧，希望对您有用。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <id>tag:xiaohanyu.me,2014-05-05:/2014/05/04/build-static-site-with-nanoc-1/</id>
    <title type="html">Build Static Site with Nanoc (I)</title>
    <published>2014-05-04T20:00:00Z</published>
    <updated>2014-05-04T20:00:00Z</updated>
    <link rel="alternate" href="http://xiaohanyu.me/2014/05/04/build-static-site-with-nanoc-1/"/>
    <content type="html">&lt;p&gt;07年我开始学会上网，那时候写 blog 应该还是一件相当时髦的事情。而我个人，作为一枚外表木讷闷骚，内心感情丰富的三好有为青年，自然对 blog 保持着强烈的好奇心，从一路转载，到絮叨自嗨，四五年坚持下来，总算找到了一点 blog 的感觉。所谓“工欲善其行，必先利其器”，头上顶了“书写是为了更好的思考”这面响当当的思想大旗，手头自然也希望能升级下一直以来残破不勘凑合能用的写作工具。于是祭出几年前刚开始折腾 Linux 时的那份耐性，断续折腾一年有余，总算略有小成。本文（及后续文章）尝试记录下这个 blog&amp;nbsp;的一些技术细节，希望对后来人有所启发。&lt;/p&gt;
&lt;h2&gt;Why&amp;nbsp;Static?&lt;/h2&gt;
&lt;p&gt;最原始的 blog 应该就是纯静态的个人主页，后来 blog 开始火的时候，各种线上平台一统天下，而对于有点折腾能力的人来说， &lt;a href="https://wordpress.org/"&gt;WordPress&lt;/a&gt; 则一支独秀。现如今，在 GitHub 当道的年代，由 &lt;a href="https://pages.github.com/"&gt;GitHub Pages&lt;/a&gt; 及其工具链 &lt;a href="http://jekyllrb.com/"&gt;Jekyll&lt;/a&gt;/&lt;a href="http://octopress.org/"&gt;Octopress&lt;/a&gt; 所组成的生态系统，则在程序员的圈子里吸引了足够的眼球和人气，也宣告着所谓 &lt;a href="http://staticsitegenerators.net/"&gt;static site generator&lt;/a&gt;（本文简称为&lt;span class="caps"&gt;SSG&lt;/span&gt;）在某种程度上的回归。&lt;/p&gt;
&lt;p&gt;So, why&amp;nbsp;static?&lt;/p&gt;
从技术上来讲，传统的 blog 就是一个简化的 &lt;a href="http://en.wikipedia.org/wiki/Content_management_system"&gt;&lt;span class="caps"&gt;CMS&lt;/span&gt;&lt;/a&gt; 系统。相较于 &lt;span class="caps"&gt;CMS&lt;/span&gt; ， blog 更多的是个人开放给外界的一个展示窗口，并不需要太多的交互和额外的用户注册管理系统（如各种 bbs/forum/group 等），&amp;nbsp;其主要技术特性是：
&lt;ul&gt;
&lt;li&gt;面向个人&lt;/li&gt;
&lt;li&gt;页面排版较为简单&lt;/li&gt;
&lt;li&gt;内容管理相对单一，基本上以 post&amp;nbsp;为主&lt;/li&gt;
&lt;li&gt;需求模块较少，基本上就是 Comments, Categories, Tags,&amp;nbsp;Archives&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;显然，动用各种 dynamic 语言和各种高大上的 &lt;span class="caps"&gt;SQL&lt;/span&gt; 数据库来实现这么几条简单的 blog 平台需求，有些牛刀杀鸡之嫌。在这方面， &lt;span class="caps"&gt;SSG&lt;/span&gt; 所遵循的 fast, lightweight, easy-deployment 是很有优势的。最简单的 blog 完全可以只是一个 post list 页面。但是纯静态的 blog 又太简陋了，因此需要通过一些 hack 的手段，在 static 的页面上加入一些 dynamic 的东西， 这个 hack 的手段，就是各种 &lt;span class="caps"&gt;SSG&lt;/span&gt; 中所谓的 compile&amp;nbsp;步骤。&lt;/p&gt;
compile 步骤是所有 &lt;span class="caps"&gt;SSG&lt;/span&gt; 的核心，它的设计好坏决定了一个 &lt;span class="caps"&gt;SSG&lt;/span&gt; 的品质。大体上讲， &lt;span class="caps"&gt;SSG&lt;/span&gt;&amp;nbsp;的工作方式如下：
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;格式转换：&lt;/strong&gt; 扫描所有 post ， 进行初步 compile（这步 compile 主要作用是进行格式转换，比如 markdown/textile -&amp;gt; html&amp;nbsp;）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;汇总metadata：&lt;/strong&gt; 汇总所有 post 的 metadata （比如 tag/category 可以用来做反向映射，datetime 可以用来给 post 进行排序），这些 metadata 信息可以在 template&amp;nbsp;渲染的时候访问。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;渲染模板：&lt;/strong&gt; 根据相应的 layout 规则，将 compile 后的 content 以及已有的 metadata 信息渲染成相应的页面 （比如每篇 post 都需要有 navbar 和 footbar， 这可以设定一下基础的页面 layout，包含公用的页面元素，然后通过模板继承或组合的方式，将 post 的内容以及相应的 metadata 信息渲染到这个 layout 中合适的位置，这就形成了你最终看到的 static page&amp;nbsp;）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span class="caps"&gt;SSG&lt;/span&gt; 最终会生成一坨静态的 html/css/js 文件，只要将其上传托管起来，所谓的 static site 就算大功告成了。不需要配置数据库，也不需要装什么 php/python(wsgi)/WordPress ，怎么样，够简单吧？ 与static site 部署简单相对的就是本地写作环境搭建的复杂，多数情况下，你需要至少掌握一门编程语言的工具链，从头到尾搭建一套完整的写作环境；你需要自己设计前端，页面排版（layout）；你还需要找到自己钟意的 Editor 和自己喜欢的 &lt;a href="http://en.wikipedia.org/wiki/Comparison_of_document_markup_languages"&gt;document markup language&lt;/a&gt; 。选择意味着纠结，也意味着灵活。 &lt;strong&gt;没有了浏览器的牵绊，你可以在自己钟爱的 Editor&amp;nbsp;里运指如飞，畅写欲言。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不同的 &lt;span class="caps"&gt;SSG&lt;/span&gt; 有不同的设计侧重点，有的提供内建的 out-of-box 的主题（ &lt;a href="http://octopress.org/"&gt;Octopress&lt;/a&gt; 基本上千篇一律），有的只提供机制（ &lt;a href="http://nanoc.ws/"&gt;Nanoc&lt;/a&gt; ）;有的只支持一种模板语言（ &lt;a href="http://ruhoh.com/"&gt;Ruhoh&lt;/a&gt; 默认支持 &lt;a href="http://mustache.github.io/"&gt;mustache&lt;/a&gt; ），有的只提供机制（ &lt;a href="http://nanoc.ws/"&gt;Nanoc&lt;/a&gt; ）;有的只支持一种标记语言（多数默认支持 &lt;a href="http://en.wikipedia.org/wiki/Markdown"&gt;Markdown&lt;/a&gt; ），有的只提供机制（ &lt;a href="http://nanoc.ws/"&gt;Nanoc&lt;/a&gt;&amp;nbsp;）;&lt;/p&gt;
相较于广大人民群众，程序员群体对于 blog&amp;nbsp;平台往往还有一些特别的需求：
&lt;ul&gt;
&lt;li&gt;没有代码高亮是不能忍的&lt;/li&gt;
&lt;li&gt;能支持数学公式的话就很高大上&lt;/li&gt;
&lt;li&gt;没有版本控制你叫我怎么活？&lt;/li&gt;
&lt;li&gt;不能一键 deploy，自动 compile/refresh&amp;nbsp;，还叫程序员吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class="caps"&gt;SSG&lt;/span&gt; 的先天不足在于，传统 blog 平台所必须的一些模块，如 Comments, Search 等必须借助第三方的服务来实现。比如 Comments 可以用 &lt;a href="https://disqus.com/"&gt;Disqus&lt;/a&gt; ， 而 Search 可以用 google site&amp;nbsp;search。&lt;/p&gt;
&lt;p&gt;总得来说， &lt;span class="caps"&gt;SSG&lt;/span&gt; 的门槛还是比较高的。高效灵活的背后，是耐心和时间。这或许就是 hack&amp;nbsp;的乐趣所在吧。&lt;/p&gt;
&lt;h2&gt;Org-mode&lt;/h2&gt;
&lt;p&gt;我选择 &lt;span class="caps"&gt;SSG&lt;/span&gt; 的第一个标准就是必须支持 &lt;a href="http://orgmode.org/"&gt;org-mode&lt;/a&gt;&amp;nbsp;。&lt;/p&gt;
&lt;p&gt;Why&amp;nbsp;org-mode?&lt;/p&gt;
&lt;p&gt;其实 &lt;a href="http://en.wikipedia.org/wiki/Markdown"&gt;Markdown&lt;/a&gt; 是相当好的文档标记语言，绝大多数 &lt;span class="caps"&gt;SSG&lt;/span&gt; 对 Markdown 都有良好的支持。多数线上服务如 GitHub 、 Stackoverflow 也是以 Markdown 为默认文档标记语言。 Markdown 的生态圈也相当繁荣， 有很多优秀的线上线下的 Editor&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;。不过 Markdown 的先天不足在于， 其设计初衷导致 Markdown 的标准过于简单，功能不够，而各方英雄为了一已之私，不得不提出各种 Markdown 扩展来满足自己的日常需求。这样看来， Markdown 生态圈一片繁荣百花争春的背后，实则是一片混乱，没有一个统一的标准，容易“厂商锁定”。所有的扩展 Markdown 语言之中， &lt;a href="https://help.github.com/articles/github-flavored-markdown"&gt;GitHub Flavored Markdown&lt;/a&gt; 和 &lt;a href="http://johnmacfarlane.net/pandoc/README.html#pandocs-markdown"&gt;Pandoc&amp;#8217;s markdown&lt;/a&gt; 是比较不错的。特别是 Pandoc&amp;#8217;s Markdown，功能完善、规范、强大，如果你不是我这样的 org-mode 死忠，那么我强烈推荐你用 Pandoc&amp;#8217;s&amp;nbsp;Markdown。&lt;/p&gt;
&lt;p&gt;而我之所以离不开 org-mode ，其一在于我个人患有严重的 Emacs 依赖症，其二是 &lt;a href="http://orgmode.org/worg/org-contrib/babel/"&gt;org-babel&lt;/a&gt; ，一个你用上了就再也离不开的东西。 org-babel 让简单静态的文档变成了完整的 live 的 workflow ，关于这点，学术界甚至有一些专门的 &lt;a href="http://orgmode.org/worg/org-papers.html"&gt;Papers&lt;/a&gt; 论述。限于篇幅，不在这里展开讨论。 Emacs 配上 org-mode&amp;nbsp;，更如香车搭上美女，快感连连，高潮不断也。&lt;/p&gt;
但是很不幸，对 org-mode 的坚持让我被迫放弃了一大半的 &lt;span class="caps"&gt;SSG&lt;/span&gt; 。事实上，在我刚开始着手调研 &lt;span class="caps"&gt;SSG&lt;/span&gt; 的时候，没有一个 &lt;span class="caps"&gt;SSG&lt;/span&gt; 提供对 org-mode 的良好支持。 org-mode 本身有一个非常原始并且极其难用的 &lt;a href="http://orgmode.org/manual/Publishing.html"&gt;org-publish&lt;/a&gt; ，稍加配置也可以当成一个原始的 &lt;span class="caps"&gt;SSG&lt;/span&gt; 来用。还有一些 &lt;a href="http://orgmode.org/worg/org-blog-wiki.html"&gt;Emacs packages&lt;/a&gt; ，基于 org-publish， 可以用来生成 static site，但是大多数都非常难用。 &lt;a href="http://renard.github.io/o-blog/"&gt;o-blog&lt;/a&gt; 看上去很漂亮，但是我始终没有搞明白怎么用。后来又尝试了下 &lt;a href="https://github.com/kelvinh/org-page"&gt;org-page&lt;/a&gt; ，还提了几个 patch ，但终究也不是很满意。于是就只能自己操刀，开始写 &lt;a href="https://github.com/xiaohanyu/org-site"&gt;org-site&lt;/a&gt;&amp;nbsp;。断续写了一个月，出来一个原型，但最终还是放弃：
&lt;ul&gt;
&lt;li&gt;Elisp 写起来并不是很happy，没有 namespace&amp;nbsp;是一大硬伤。&lt;/li&gt;
&lt;li&gt;Org-mode 的代码设计并没有为开放式的 &lt;span class="caps"&gt;API&lt;/span&gt; 做过考虑。理论上，我可以把 Emacs org-mode 当成一个文档格式转换器，将 org-mode 转换成 html/pdf ，但是由于 Emacs 的特殊性，很多 Elisp &lt;span class="caps"&gt;API&lt;/span&gt; 都是以 Emacs &lt;a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Buffers.html"&gt;buffer&lt;/a&gt; 而不是 file 为操作对象，这就让我必须写很多的 wrapper 代码，然后通过类似于 &lt;code&gt;(with-temp-buffer (do-some-thing))&lt;/code&gt;&amp;nbsp;的手段来绕过这个限制。&lt;/li&gt;
&lt;li&gt;org-publish &lt;span class="caps"&gt;API&lt;/span&gt;&amp;nbsp;依赖很多全局变量，写起来很别扭，经常要去翻原代码才能搞明白某个变量的意思。&lt;/li&gt;
&lt;li&gt;org-mode 7.x 和 8.x&amp;nbsp;之间变动很大，代码兼容性维护任重道远。&lt;/li&gt;
&lt;li&gt;org-mode 生成的 html 模块性太差，需要用各种 regexp 提取有用的 body/&lt;a href="http://en.wikipedia.org/wiki/Table_of_contents"&gt;&lt;span class="caps"&gt;TOC&lt;/span&gt;&lt;/a&gt; 并过滤掉不需要的 header/footer&amp;nbsp;，不美。&lt;/li&gt;
&lt;li&gt;一个优秀的 &lt;span class="caps"&gt;SSG&lt;/span&gt; ，除了格式转换，还需要很多配套的模块，比如自动检测文件改动、自动编译、灵活的路由规则等，而这些用 Elisp&amp;nbsp;实现起来都很麻烦。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;至此，自动动手丰衣足食的计划宣告破产，被迫寻找并尝试 hack 一些成型的 &lt;span class="caps"&gt;SSG&lt;/span&gt; ，来支持 org-mode 写作。我最终的选择是 &lt;a href="http://nanoc.ws/"&gt;Nanoc&lt;/a&gt;&amp;nbsp;。&lt;/p&gt;
&lt;h2&gt;Nanoc&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://nanoc.ws/"&gt;Nanoc&lt;/a&gt; 是我用过的所有 &lt;span class="caps"&gt;SSG&lt;/span&gt; 中最为灵活，也是使用门槛最高的一个。 Nanoc 官方的入门 &lt;a href="http://nanoc.ws/docs/tutorial/"&gt;Tutorial&lt;/a&gt; 中明确说明，你必须 &amp;quot;have a basic understanding of Ruby and command line&amp;quot;， 才有可能玩得通 Nanoc 。在我个人看来， Nanoc 的设计基本上严格遵循了 Unix 中 &amp;quot;Provide mechanism, not policy&amp;quot; 的哲学。用软件工程的术语来说， Nanoc 提供的是 library ，而非一套成型的 &lt;span class="caps"&gt;SSG&lt;/span&gt; 软件。 Nanoc 既不限定你所用的文档标记语言 &amp;#8212; 你可以用 Markdown/Textile/Org-mode ，也不指定相应的编译规则，更不提供默认的 out-of-box&amp;nbsp;的主题样式。总之，一切要自己来，学习曲线颇为陡峭，但学成之后可以随心所欲。&lt;/p&gt;
Nanoc 创造了自己的术语体系，每个概念相互独立又彼此联系。理解了这些术语也就理解了 nanoc&amp;nbsp;的工作原理：
&lt;ul&gt;
&lt;li&gt;item: 是 nanoc 要处理的实体。一个 item 可以是 html/css/markdown&amp;nbsp;等文本文件，也可以是图片，还可以是你自己凭空创造出来的虚拟文件。&lt;/li&gt;
&lt;li&gt;rule: 决定 nanoc 处理 item 的步骤。 rule 分为两种， compilation rule 和 routing rule 。 其中 compilation rule 又分为 filter rule 和 layout rule 。 filter rule 一般用于文档格式转换，而 layout rule 则用于页面布局排版。 routing rule 决定 item 在 compile 之后在 output&amp;nbsp;中的路径。&lt;/li&gt;
&lt;li&gt;helper: 一些辅助代码，用于扩展 nanoc&amp;nbsp;。&lt;/li&gt;
&lt;li&gt;metadata: 元信息。 nanoc 对于每个 item 可附加的 metadata 没有任何限制。典型的 metadata 可以是 tag/category/datatime&amp;nbsp;。&lt;/li&gt;
&lt;li&gt;representation: 可以理解为输出格式。比如，同一个 item 可以同时 compile 为 html/pdf 两种格式。每种格式可以用自己独立的 rule&amp;nbsp;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以说， nanoc 为 &lt;span class="caps"&gt;SSG&lt;/span&gt; 的领域制定了一套相当棒的 standard 。事实上， 确实有人仿照着 nanoc 的 standard ，用 Haskell 重新实现了 nanoc ，这就是 &lt;a href="http://jaspervdj.be/hakyll/"&gt;hakyll&lt;/a&gt;&lt;a href="#fn2" class="footnoteRef" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; 。我曾经短暂尝试过 hakyll ，但最终放弃，回到了 nanoc 的怀抱。而这基本上要归功于 Ruby&amp;nbsp;。&lt;/p&gt;
&lt;h2&gt;Ruby&lt;/h2&gt;
&lt;p&gt;我并不是某一门编程语言的死忠。如果让我用一个字来形容 Ruby ，那就是“舒服”。是的， &lt;a href="http://en.wikipedia.org/wiki/Yukihiro_Matsumoto"&gt;Matz&lt;/a&gt; 没有骗你， Ruby 是写起来相当舒服的一门语言。 Ruby 的包管理机制 &lt;a href="http://bundler.io/"&gt;bundler&lt;/a&gt; + &lt;a href="https://rubygems.org/"&gt;gem&lt;/a&gt; 是我用过的所有包管理器中最先进最好用的， 比之于什么 Python 的 &lt;a href="http://www.virtualenv.org/en/latest/"&gt;virtualenv&lt;/a&gt; + &lt;a href="http://www.pip-installer.org/en/latest/"&gt;pip&lt;/a&gt; 之流要好用太多。至于 Haskell 的 &lt;a href="http://www.haskell.org/cabal/"&gt;cabal&lt;/a&gt; 基本上就是个奇葩的存在，连基本的 uninstall 功能都没有（是不是想起了 Python 的 &lt;code&gt;easy_install&lt;/code&gt; ？），更不用提类似于 virtualenv/sandbox 这类先进功能了。不过这些都还可以忍受， Haskell 的 cabal 最蛋疼最奇葩的一点就是，好好的用着 &lt;code&gt;cabal install&lt;/code&gt; ，说不定哪一天就会蹦出来各种莫名其妙的依赖问题， &lt;a href="http://en.wikipedia.org/wiki/Dependency_hell"&gt;dependency hell&lt;/a&gt; ， 唯一的解决办法就是 &lt;code&gt;rm -rf $HOME/.cabal&lt;/code&gt; ， 然后重装然后祈祷……而 Haskell 又是一门编译型的静态语言，这就使得装 package&amp;nbsp;的时间很长，令人不快。&lt;/p&gt;
&lt;p&gt;语言层面， Ruby 中内置的 regexp （对比下 Python 的 &lt;code&gt;re.compile&lt;/code&gt; ） 强大易用；其完整的对 lambda/block 的支持（对比下 Python 中阉割的 lambda ），能让每一个有点 Lisp 基础的人找到熟悉的感觉； Ruby 从 Unix Shell 以及 Perl 中借鉴而来的很多小聪明如 &lt;a href="http://en.wikipedia.org/wiki/Here_document"&gt;here document&lt;/a&gt;/&lt;a href="http://en.wikipedia.org/wiki/String_interpolation"&gt;string interpolation&lt;/a&gt;/command interpolation(Ruby backticks)， 使 Ruby 超越了 Python/Perl/Shell ，成为写 quick and dirty 的 Unix Script 的上上之选； Ruby 社区一些极富创造力的一些 package 如 &lt;a href="http://rake.rubyforge.org/"&gt;rake&lt;/a&gt;/&lt;a href="https://github.com/guard/guard"&gt;guard&lt;/a&gt; ，则让你的 hack&amp;nbsp;之旅充满了快乐。&lt;/p&gt;
&lt;p&gt;尽管 Ruby 这样那样好，但是 Haskell 社区有一枚神器，让人欲罢不能，这就是文档格式转换的瑞士军刀 &amp;#8212; &lt;a href="http://johnmacfarlane.net/pandoc/"&gt;Pandoc&lt;/a&gt;&amp;nbsp;。&lt;/p&gt;
&lt;h2&gt;Pandoc&lt;/h2&gt;
&lt;p&gt;文档格式转换一直是一大难题，究其原因，是在于不同的文档格式有不同的表现能力和设计侧重点。比如原始的 Markdown 格式没有 table （表格）的支持，你怎么把 html 转换成 Markdown ? 反过来， html 中的 form 转换成其它格式，又该如何表现？ Microsoft Word 2003及之前版本的文档格式都是二进制且没有公开的文档格式标准， 想要完整的支持这种格式需要做大量的反向工程（ &lt;a href="https://www.openoffice.org/"&gt;OpenOffice&lt;/a&gt; 和 &lt;a href="https://www.libreoffice.org/"&gt;LibreOffice&lt;/a&gt;&amp;nbsp;干的就是这事，可想这工作量）。&lt;/p&gt;
&lt;p&gt;文档格式转换的软件千千万万，但是多数都只是 ad-hoc 的办法， pandoc 的创新之处在于发明了一种中间格式（ &lt;a href="http://johnmacfarlane.net/pandoc/scripting.html"&gt;json-formatted &lt;span class="caps"&gt;AST&lt;/span&gt;&lt;/a&gt;&amp;nbsp;），即先将原始文档格式先解析并转换成这种中间格式，然后经过系列处理转换成目标文档格式，从而提供了大一统的解决方案。&lt;/p&gt;
&lt;pre class="example"&gt;&lt;code&gt;                         source format
                              ↓
                           (pandoc)
                              ↓
                      JSON-formatted AST
                              ↓
                           (filter)
                              ↓
                      JSON-formatted AST
                              ↓
                           (pandoc)
                              ↓
                        target format
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pandoc 对于每种支持的输入格式，都提供了完整的 parser （ pandoc 中叫做 reader ），通过 parser 将输入文档转换成结构化 json 格式的 &lt;a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree"&gt;&lt;span class="caps"&gt;AST&lt;/span&gt;&lt;/a&gt; 。然后我们可以根据自己的需求，写一些脚本来操作 pandoc &lt;span class="caps"&gt;AST&lt;/span&gt; ，再转换成最终的输出目标格式（ Pandoc 中叫做 writer ）。Pandoc 把这个操作 &lt;span class="caps"&gt;AST&lt;/span&gt; 的程序脚本叫做 &lt;a href="http://johnmacfarlane.net/pandoc/scripting.html#json-filters"&gt;filter&lt;/a&gt; ，借助 filter ，理论上可以实现非常丰富的功能。至于调用 filter 的方法，最简单的是通过 Unix&amp;nbsp;管道操作，比如：&lt;/p&gt;
&lt;pre class="sourceCode bash"&gt;&lt;code class="sourceCode bash"&gt;&lt;span class="kw"&gt;pandoc&lt;/span&gt; -f SOURCEFORMAT -t json &lt;span class="kw"&gt;|&lt;/span&gt; &lt;span class="kw"&gt;runhaskell&lt;/span&gt; filter.hs &lt;span class="kw"&gt;|&lt;/span&gt; &lt;span class="kw"&gt;pandoc&lt;/span&gt; -f json -t TARGETFORMAT&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pandoc 的首选格式语言是 Markdown 。为了弥补 Markdown 的先天不足， pandoc 在原始 Markdown 的基础上增加了许多有用的扩展。通过这些扩展， &lt;a href="http://johnmacfarlane.net/pandoc/README.html#pandocs-markdown"&gt;Pandoc&amp;#8217;s markdown&lt;/a&gt;&amp;nbsp;自成一套完备、规范、通用、强大的文档标记语言。&lt;/p&gt;
&lt;p&gt;Pandoc 在 &lt;span class="caps"&gt;1.12.3.2&lt;/span&gt; 版本之前是不支持 org-mode 作为输入格式的。这也让我头疼了许久。我最原始的想法是将 Emacs 当成一个 org-mode 的文档格式转换器，定制 emacs org-mode filter 集成到 nanoc&amp;nbsp;：&lt;/p&gt;
&lt;pre class="sourceCode ruby"&gt;&lt;code class="sourceCode ruby"&gt;&lt;span class="kw"&gt;module&lt;/span&gt; &lt;span class="dt"&gt;Nanoc&lt;/span&gt;::&lt;span class="dt"&gt;Filters&lt;/span&gt;

  &lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;OrgModeHtml&lt;/span&gt; &amp;lt; &lt;span class="dt"&gt;Nanoc&lt;/span&gt;::&lt;span class="dt"&gt;Filter&lt;/span&gt;
    identifier &lt;span class="st"&gt;:org_mode_html&lt;/span&gt;
    type &lt;span class="st"&gt;:text&lt;/span&gt; =&amp;gt; &lt;span class="st"&gt;:text&lt;/span&gt;

    require &lt;span class="st"&gt;&amp;#39;systemu&amp;#39;&lt;/span&gt;
    require &lt;span class="st"&gt;&amp;#39;tempfile&amp;#39;&lt;/span&gt;

    &lt;span class="kw"&gt;def&lt;/span&gt; run(content, params = {})
      &lt;span class="co"&gt;# Run command&lt;/span&gt;

      tmp_org_file = &lt;span class="dt"&gt;Tempfile&lt;/span&gt;.new(&lt;span class="st"&gt;&amp;#39;nanoc_tmp_org_file&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;/tmp&amp;#39;&lt;/span&gt;)
      tmp_org_file &amp;lt;&amp;lt; content
      tmp_org_file.close(&lt;span class="dv"&gt;nil&lt;/span&gt;)

      elisp_code =&lt;span class="ot"&gt; %{&lt;/span&gt;
&lt;span class="st"&gt;(progn&lt;/span&gt;
&lt;span class="st"&gt;  (require &amp;#39;org)&lt;/span&gt;
&lt;span class="st"&gt;  (find-file-read-only &amp;quot;&lt;/span&gt;&lt;span class="ot"&gt;#{&lt;/span&gt;tmp_org_file.path&lt;span class="ot"&gt;}&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;)&lt;/span&gt;
&lt;span class="st"&gt;  (org-mode)&lt;/span&gt;
&lt;span class="st"&gt;  (if (version&amp;lt; org-version &amp;quot;8.0&amp;quot;)&lt;/span&gt;
&lt;span class="st"&gt;      (progn&lt;/span&gt;
&lt;span class="st"&gt;        (setq org-export-html-postamble nil)&lt;/span&gt;
&lt;span class="st"&gt;        (org-export-as-html 3))&lt;/span&gt;
&lt;span class="st"&gt;    (progn&lt;/span&gt;
&lt;span class="st"&gt;      (setq org-html-postamble nil)&lt;/span&gt;
&lt;span class="st"&gt;      (org-html-export-as-html)))&lt;/span&gt;
&lt;span class="st"&gt;  (message &amp;quot;%s&amp;quot; (buffer-string)))&lt;/span&gt;
&lt;span class="ot"&gt;}&lt;/span&gt;

      cmd = [&lt;span class="st"&gt;&amp;#39;emacs&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;-Q&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;--batch&amp;#39;&lt;/span&gt;,
             &lt;span class="st"&gt;&amp;#39;--eval&amp;#39;&lt;/span&gt;, elisp_code]

      stdout = &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;
      stderr = &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;
      status = systemu(cmd,
                       &lt;span class="st"&gt;&amp;#39;stdout&amp;#39;&lt;/span&gt; =&amp;gt; stdout,
                       &lt;span class="st"&gt;&amp;#39;stderr&amp;#39;&lt;/span&gt; =&amp;gt; stderr)

      &lt;span class="co"&gt;# Show errors&lt;/span&gt;
      &lt;span class="kw"&gt;unless&lt;/span&gt; status.success?
        &lt;span class="dt"&gt;$stderr&lt;/span&gt;.puts stderr
        raise &lt;span class="st"&gt;&amp;quot;Emacs org-mode filter failed with status &lt;/span&gt;&lt;span class="ot"&gt;#{&lt;/span&gt;status&lt;span class="ot"&gt;}&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;
      &lt;span class="kw"&gt;end&lt;/span&gt;

      &lt;span class="co"&gt;# Get result&lt;/span&gt;
      body = &lt;span class="ot"&gt;/&amp;lt;body&amp;gt;.*&amp;lt;\/body&amp;gt;/m&lt;/span&gt;.match(stderr)
      body[&lt;span class="dv"&gt;0&lt;/span&gt;]
    &lt;span class="kw"&gt;end&lt;/span&gt;

  &lt;span class="kw"&gt;end&lt;/span&gt;

&lt;span class="kw"&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码的大体思路是将 emacs 当成 elisp 的解释器，喂给其一段 elisp 代码，调用 org-mode 的 export 功能 （ org-mode 7.x 版本中调用 &lt;code&gt;(org-export-as-html)&lt;/code&gt; ， 8.x 版本中调用 &lt;code&gt;(org-html-export-as-html)&lt;/code&gt; ），然后再通过 regexp 正则匹配的方式提取出 html 中的 body 部分作为 nanoc filter&amp;nbsp;的返回值。显而易见，这段代码冗长，乏味，别扭，不美。&lt;/p&gt;
&lt;p&gt;好在我生逢其时，英雄出世， &lt;a href="http://zeitlens.com/"&gt;Albert Krewinkel&lt;/a&gt; 大手笔横空祭出几个 patch ，给 pandoc 提供了一个完备的 org-reader ，把我感动得一塌糊涂，我还特别写了封邮件感谢人家。一番 &lt;code&gt;cabal install&lt;/code&gt; 之后， pandoc 总算能支持 org-mode&amp;nbsp;作为其输入格式了，很完美。&lt;/p&gt;
&lt;p&gt;最后要解决的问题就是 pandoc 和 nanoc 的集成。 nanoc 本身有一个内建的 &lt;code&gt;Nanoc::Filters::Pandoc&lt;/code&gt; ，调用的是 &lt;a href="https://github.com/alphabetum/pandoc-ruby"&gt;PandocRuby&lt;/a&gt; 。但是 nanoc 本身的 &lt;span class="caps"&gt;API&lt;/span&gt; 和 PandocRuby &lt;span class="caps"&gt;API&lt;/span&gt; 并不是很匹配，无法传递一些参数来启用 pandoc 的某些高级特性 （参考 &lt;a href="http://stackoverflow.com/questions/14646741/nanoc-how-can-i-pass-options-to-pandoc-ruby"&gt;stackoverflow&lt;/a&gt; ）。万般无奈之下，只能自己动手，重写一个 nanoc pandoc filter，完整代码参考 &lt;a href="https://gist.github.com/xiaohanyu/9866531"&gt;github gist&lt;/a&gt;&amp;nbsp;。&lt;/p&gt;
&lt;pre class="sourceCode ruby"&gt;&lt;code class="sourceCode ruby"&gt;&lt;span class="kw"&gt;module&lt;/span&gt; &lt;span class="dt"&gt;Nanoc&lt;/span&gt;::&lt;span class="dt"&gt;Filters&lt;/span&gt;

  &lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;PandocHtml&lt;/span&gt; &amp;lt; &lt;span class="dt"&gt;Nanoc&lt;/span&gt;::&lt;span class="dt"&gt;Filter&lt;/span&gt;
    identifier &lt;span class="st"&gt;:pandoc_html&lt;/span&gt;
    type &lt;span class="st"&gt;:text&lt;/span&gt; =&amp;gt; &lt;span class="st"&gt;:text&lt;/span&gt;

    &lt;span class="kw"&gt;def&lt;/span&gt; run(content, params = {})
      input_format = &lt;span class="kw"&gt;case&lt;/span&gt; item[&lt;span class="st"&gt;:extension&lt;/span&gt;]
                     &lt;span class="kw"&gt;when&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;org&amp;#39;&lt;/span&gt;
                       &lt;span class="st"&gt;&amp;#39;org&amp;#39;&lt;/span&gt;
                     &lt;span class="kw"&gt;when&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;md&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;markdown&amp;#39;&lt;/span&gt;
                       &lt;span class="st"&gt;&amp;#39;markdown&amp;#39;&lt;/span&gt;
                     &lt;span class="kw"&gt;end&lt;/span&gt;

      &lt;span class="st"&gt;`pandoc --mathjax -f &lt;/span&gt;&lt;span class="ot"&gt;#{&lt;/span&gt;input_format&lt;span class="ot"&gt;}&lt;/span&gt;&lt;span class="st"&gt; -t html5 &amp;lt; &lt;/span&gt;&lt;span class="ot"&gt;#{&lt;/span&gt;item.raw_filename&lt;span class="ot"&gt;}&lt;/span&gt;&lt;span class="st"&gt;`&lt;/span&gt;
    &lt;span class="kw"&gt;end&lt;/span&gt;

  &lt;span class="kw"&gt;end&lt;/span&gt;

&lt;span class="kw"&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码思路很简单，就是通过 Ruby backticks 直接调用 pandoc ，然后将 pandoc 命令的 stdout 作为 nanoc filter 的返回值。通过进一步配置， nanoc 可以调用 pandoc 同时生成 html 和 pdf ，这样一来，同样的文章，即可以线上浏览，也可以打印下载，得益于 pandoc 的优秀设计， html 和 pdf&amp;nbsp;版本的文章具有一致出色的排版效果。&lt;/p&gt;
&lt;p&gt;至此，核心的技术问题已经基本解决，剩下的就是前端设计了，这是我的弱项，为了能让这个 blog 有一个“不那么难看”的样式，我特别花时间学习系统地学习了下 &lt;span class="caps"&gt;HTML5&lt;/span&gt; 和&amp;nbsp;&lt;span class="caps"&gt;CSS3&lt;/span&gt;。这部分内容冗长乏味，非核心所在，下篇再表。&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&amp;lt;&lt;a href="http://freemind.pluskid.org/technology/the-unbearable-madness-of-static-blog-generators/"&gt;The Unbearable Madness of Static Blog Generators&lt;/a&gt;&amp;gt;， pluskid 的 blog ，重点介绍了 ruhoh&amp;nbsp;。&lt;/li&gt;
&lt;li&gt;&amp;lt;&lt;a href="http://clarkdave.net/2012/02/building-a-static-blog-with-nanoc/"&gt;Building a static blog with nanoc&lt;/a&gt;&amp;gt;， nanoc 入门教程，简洁明了&amp;nbsp;。&lt;/li&gt;
&lt;li&gt;nanoc powered&amp;nbsp;的网站包括：
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developer.github.com/"&gt;GitHub Developer&amp;nbsp;Site&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://guides.spreecommerce.com/api/"&gt;Spree Commerce &lt;span class="caps"&gt;API&lt;/span&gt;&amp;nbsp;site&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="caps"&gt;SSG&lt;/span&gt; 名录大全： &lt;a href="http://staticsitegenerators.net/" class="uri"&gt;http://staticsitegenerators.net/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;&lt;a href="http://kelvinh.github.io/blog/2012/11/27/growth-process-of-org-page/"&gt;Org-page的成长史&lt;/a&gt;&amp;gt;，介绍了基于 org-mode 的 &lt;span class="caps"&gt;SSG&lt;/span&gt;&amp;nbsp;。&lt;/li&gt;
&lt;/ul&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;线上 Editor ： &lt;a href="http://dillinger.io/"&gt;Dillinger&lt;/a&gt;/&lt;a href="https://stackedit.io/"&gt;StackEdit&lt;/a&gt; ；线下 Editor ： &lt;a href="http://mouapp.com/"&gt;Mou&lt;/a&gt; 。&lt;a href="#fnref1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;这其中有个八卦， hakyll 的作者 &lt;a href="http://jaspervdj.be/"&gt;Jasper&lt;/a&gt; 和 nanoc 的作者 &lt;a href="http://stoneship.org/"&gt;Denis Defreyne&lt;/a&gt; 在生活中是好朋友。而在某一年的 April fools&amp;#8217; day， Denis 写了篇 &amp;lt;&lt;a href="http://nanoc.ws/the-road-to-nanoc-4-0/"&gt;The road to nanoc &lt;span class="caps"&gt;4.0&lt;/span&gt;&lt;/a&gt;&amp;gt; ， 大意是要用 haskell 重写 nanoc 。&lt;a href="#fnref2"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>
  </entry>
  <entry>
    <id>tag:xiaohanyu.me,2014-04-17:/2014/04/16/new-blog-new-start/</id>
    <title type="html">New Blog, New Start</title>
    <published>2014-04-16T20:00:00Z</published>
    <updated>2014-04-16T20:00:00Z</updated>
    <link rel="alternate" href="http://xiaohanyu.me/2014/04/16/new-blog-new-start/"/>
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;书写是为了更好的思考。&lt;/p&gt;
&lt;p&gt;&amp;#8211;&amp;nbsp;刘未鹏&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;刚上大学的时候，我给高中同桌发短信咨询&lt;span class="caps"&gt;QQ&lt;/span&gt;该怎么用，他回了一条“计算机的教育要从娃娃抓起”……那时候我刚刚学会如何从控制面板里面卸载软件，刚刚学会收发 Email ，写 blog&amp;nbsp;对我来说是一件相当时髦的事情啊。&lt;/p&gt;
&lt;p&gt;最开始用的是线上服务，什么 Dreamhost/&lt;span class="caps"&gt;DNS&lt;/span&gt;/WordPress 对于当时的我来说是难以逾越的技术难题。大概有一年多的时间，我在百度空间，和讯博客，博客园， &lt;a href="http://en.wikipedia.org/wiki/Windows_Live_Spaces"&gt;Windows Live Spaces&lt;/a&gt; 等各种 blog 平台上写（ &lt;del&gt;转载&lt;/del&gt; ）文章，玩（ &lt;del&gt;自嗨&lt;/del&gt; ）得不亦乐乎。后来咱不是会写点小程序了嘛，就希望能找个支持代码高亮，并且广告要少些的博客平台。无意间找到了 &lt;a href="http://www.is-programmer.com/"&gt;is-programmer&lt;/a&gt;&amp;nbsp;，试用了下，很不错，就在那里安了家，迄已五年。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://cnlox.is-programmer.com/"&gt;行者无疆 始于足下&lt;/a&gt;，这个 blog 基本上忠实地记录了我个人学习计算机的历程（ &lt;del&gt;基本上是瞎折腾&lt;/del&gt; ）。最开始是学习（ &lt;del&gt;折腾&lt;/del&gt; ） Linux/LaTeX ，后来忙于学业 （Open&lt;span class="caps"&gt;GL&lt;/span&gt;/Assembly），再后来开始实习（终于学会了&lt;span class="caps"&gt;SSH&lt;/span&gt;/&lt;span class="caps"&gt;SCP&lt;/span&gt;/Shell Script，掩面），疲于奔命，总算天幸顺利毕业，进入百度，后来偷得浮生，后来一夜之间……五年时间，不长不短，对于 &lt;a href="http://blog.watashi.ws/"&gt;天才选手&lt;/a&gt; ，五年可以从无到有，站到世界之颠。对于我辈俗人，五年时间，也许刚刚够敲开计算机世界的大门吧。 五年来如果说有什么成就，就是始终没有离开 Open Source。这种坚持终于让我在去年收获了 200+ 个 github star，也让我进了 OpenStack 的贡献者名单。想想自己写的代码能够跑在别人的机器上， make the world a better place，还是很开心的。是谁说过，&amp;lt;&lt;a href="http://book.douban.com/subject/4006425/"&gt;我是一只 &lt;span class="caps"&gt;IT&lt;/span&gt; 小小鸟&lt;/a&gt;&amp;gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;认真的写作有如雕刻。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;工作以后， blog 更新的频率大幅下降， 每篇 blog 的长度却大幅提高，随之而来的就是每篇 blog 写作时间的水涨船高。一方面美其名曰“工作忙（ &lt;del&gt;其实是懒&lt;/del&gt; ）”，另一方面，自己偶尔回翻下自己以前的文章，个中观点语句，常感羞愧难当。因此每次写作，总是有些诚惶诚恐，咬文嚼字，条分缕析，大耗体力，唯恐贻笑大方。&lt;/p&gt;
&lt;p&gt;写作有如登山，一日风睛，柳暗花明，辛苦求索的背后，是对自己生活的反思和锤炼。我常常在认真的写作中发现自己的思想盲点，正如行者登山，辛苦自不必说，孤独也是常态，只是这辛苦孤独之外，常常会伴随着山重水复般的壮丽风景。&lt;/p&gt;
&lt;p&gt;大概在一年前，我开始着手寻找新的 blog 平台， &lt;a href="http://www.is-programmer.com/"&gt;is-programmer&lt;/a&gt; 对新手程序员而言是相当好的 blog 的平台，但是已经越来越无法满足我的需求，因此我将我的注意力转到了所谓的 static blog/site generator 上。这个折腾的过程一波三折，高潮不断，快感连连，折腾的结果就是你现在看到的新的 &lt;a href="http://xiaohanyu.me"&gt;行者无疆 始于足下&lt;/a&gt;&amp;nbsp;。其中的技术细节繁复冗长，我会再写一篇文章加以详述。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;行走 思考&amp;nbsp;在路上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;New blog, new start.&amp;nbsp;“身体与心灵，总要有一个在路上”，自勉。&lt;/p&gt;
</content>
  </entry>
</feed>

